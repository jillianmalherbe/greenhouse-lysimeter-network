
def getWattsY(spectrometerWavelength, rawSampleDataY, rawDarkDataY, rawSampleDataCapturedIntegrationTimeInMS, calibrationFilePath, aperturePercentage=100):
    """
    Calculate the Watts/m^2 spectral data using the provided raw sample data, dark data, and calibration file.

    Args:
        spectrometerWavelength (array or list): Wavelength values for the spectrometer.
        rawSampleDataY (array or list): Raw sample spectral data directly obtained from the spectrometer, without dark subtraction.
        rawDarkDataY (array or list): Raw dark spectral data (to subtract from the sample data). The spectrometer should be covered to ensure no light enters.
        rawSampleDataCapturedIntegrationTimeInMS (float): The integration time in milliseconds at which the sample data was captured.
        calibrationFilePath (str): The path to the StellarNet .CAL calibration file. It should be a valid StellarNet calibration file.
        aperturePercentage (float, optional): Percentage of the aperture value (the amount of light entering the spectrometer). Default is 100%.

    Returns:
        numpy.ndarray: A numpy array representing the Watts/m^2 spectrum corresponding to the provided wavelengths.

    Notes:
        - `spectrometerWavelength`, `rawSampleDataY`, and `rawDarkDataY` must have the same length. The `spectrometerWavelength` array should correspond to the provided `rawSampleDataY` and `rawDarkDataY`.
    """
    
    # Step 1: Load the calibration data and interpolate it to match the spectrometerWavelength
    calibrationData = np.genfromtxt(calibrationFilePath, skip_header=31, skip_footer=1)  # Read the calibration data from the file
    interpolatedCalibrationDataY = np.interp(spectrometerWavelength, calibrationData[:, 0], calibrationData[:, 1], left=0, right=0)  # Interpolate calibration data

    # Step 2: Extract the calibration integration time from the .CAL file
    calibrationIntegrationTime = int(
        next(line.strip().split('=')[1]
            for line in open(calibrationFilePath, 'r') if 'Csf1' in line))  # Extract integration time from the calibration file

    # Step 3: Subtract dark data from the sample data to obtain the corrected scope data
    scopeY = np.subtract(rawSampleDataY, rawDarkDataY)  # Subtract dark data from sample data to correct for dark noise
    scopeY[scopeY < 0] = 0  # Ensure no negative values after subtraction

    # Step 4: Normalize the raw scope data based on the integration times (calibration and sample)
    normRatio = float(calibrationIntegrationTime) / float(rawSampleDataCapturedIntegrationTimeInMS)  # Calculate the normalization ratio

    # Step 5: Convert the spectral data to Watts, applying the aperture scaling
    wattsY = np.asarray(scopeY * interpolatedCalibrationDataY[:len(spectrometerWavelength)] * normRatio * (100.0 / aperturePercentage))  # Convert to Watts

    wattsY[wattsY < 0] = 0  # Ensure no negative values in the Watts data
    
    return {'X':spectrometerWavelength, 'Y':wattsY}  # Return the calculated Watts values